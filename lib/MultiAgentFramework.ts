export interface Agent {
  id: string
  name: string
  role: string
  capabilities: string[]
  status: "idle" | "working" | "error"
  config: Record<string, any>
}

export interface Task {
  id: string
  type: string
  description: string
  assignedTo?: string
  status: "pending" | "in-progress" | "completed" | "failed"
  result?: any
  error?: string
  createdAt: Date
  completedAt?: Date
}

export interface MultiAgentConfig {
  maxConcurrentTasks: number
  taskTimeout: number
  retryAttempts: number
  communicationProtocol: "direct" | "queue" | "broadcast"
}

export class MultiAgent {
  private agents: Map<string, Agent> = new Map()
  private tasks: Map<string, Task> = new Map()
  private config: MultiAgentConfig

  constructor(config: Partial<MultiAgentConfig> = {}) {
    this.config = {
      maxConcurrentTasks: 5,
      taskTimeout: 30000,
      retryAttempts: 3,
      communicationProtocol: "direct",
      ...config,
    }
  }

  addAgent(agent: Agent): void {
    this.agents.set(agent.id, agent)
  }

  removeAgent(agentId: string): boolean {
    return this.agents.delete(agentId)
  }

  getAgent(agentId: string): Agent | undefined {
    return this.agents.get(agentId)
  }

  getAllAgents(): Agent[] {
    return Array.from(this.agents.values())
  }

  async assignTask(task: Task): Promise<void> {
    this.tasks.set(task.id, { ...task, status: "pending" })

    // Find available agent
    const availableAgent = this.findAvailableAgent(task.type)
    if (availableAgent) {
      await this.executeTask(task.id, availableAgent.id)
    }
  }

  private findAvailableAgent(taskType: string): Agent | undefined {
    return Array.from(this.agents.values()).find(
      (agent) => agent.status === "idle" && agent.capabilities.includes(taskType),
    )
  }

  private async executeTask(taskId: string, agentId: string): Promise<void> {
    const task = this.tasks.get(taskId)
    const agent = this.agents.get(agentId)

    if (!task || !agent) return

    // Update status
    task.status = "in-progress"
    agent.status = "working"

    try {
      // Simulate task execution
      const result = await this.performTask(task, agent)

      task.status = "completed"
      task.result = result
      task.completedAt = new Date()
      agent.status = "idle"
    } catch (error) {
      task.status = "failed"
      task.error = error instanceof Error ? error.message : String(error)
      agent.status = "idle"
    }
  }

  private async performTask(task: Task, agent: Agent): Promise<any> {
    // Simulate different task types
    switch (task.type) {
      case "data-analysis":
        return { analysis: `Data analyzed by ${agent.name}`, confidence: 0.95 }
      case "code-generation":
        return { code: `// Generated by ${agent.name}\nfunction example() { return true; }` }
      case "api-call":
        return { response: `API called by ${agent.name}`, status: 200 }
      default:
        return { message: `Task ${task.type} completed by ${agent.name}` }
    }
  }

  getTaskStatus(taskId: string): Task | undefined {
    return this.tasks.get(taskId)
  }

  getAllTasks(): Task[] {
    return Array.from(this.tasks.values())
  }

  getAgentWorkload(agentId: string): number {
    return Array.from(this.tasks.values()).filter(
      (task) => task.assignedTo === agentId && task.status === "in-progress",
    ).length
  }
}

export class MultiAgentFramework {
  private multiAgent: MultiAgent
  private workflows: Map<string, any> = new Map()

  constructor(config?: Partial<MultiAgentConfig>) {
    this.multiAgent = new MultiAgent(config)
  }

  createAgent(config: Omit<Agent, "status">): Agent {
    const agent: Agent = {
      ...config,
      status: "idle",
    }
    this.multiAgent.addAgent(agent)
    return agent
  }

  async executeWorkflow(workflowId: string, input: any = {}): Promise<any> {
    const workflow = this.workflows.get(workflowId)
    if (!workflow) {
      throw new Error(`Workflow ${workflowId} not found`)
    }

    // Create tasks from workflow steps
    const tasks: Task[] = workflow.steps.map((step: any, index: number) => ({
      id: `${workflowId}-task-${index}`,
      type: step.type,
      description: step.description || `Step ${index + 1}`,
      status: "pending" as const,
      createdAt: new Date(),
    }))

    // Execute tasks
    for (const task of tasks) {
      await this.multiAgent.assignTask(task)
    }

    // Wait for completion (simplified)
    await new Promise((resolve) => setTimeout(resolve, 1000))

    return {
      workflowId,
      status: "completed",
      results: tasks.map((task) => this.multiAgent.getTaskStatus(task.id)),
    }
  }

  registerWorkflow(id: string, workflow: any): void {
    this.workflows.set(id, workflow)
  }

  getFrameworkStatus(): {
    agents: Agent[]
    tasks: Task[]
    activeWorkflows: number
  } {
    return {
      agents: this.multiAgent.getAllAgents(),
      tasks: this.multiAgent.getAllTasks(),
      activeWorkflows: this.workflows.size,
    }
  }

  async communicateAgents(fromAgentId: string, toAgentId: string, message: any): Promise<void> {
    const fromAgent = this.multiAgent.getAgent(fromAgentId)
    const toAgent = this.multiAgent.getAgent(toAgentId)

    if (!fromAgent || !toAgent) {
      throw new Error("Agent not found")
    }

    // Simulate agent communication
    console.log(`Communication from ${fromAgent.name} to ${toAgent.name}:`, message)
  }

  getMultiAgent(): MultiAgent {
    return this.multiAgent
  }
}

export default MultiAgentFramework
